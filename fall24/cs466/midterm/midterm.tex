\documentclass{report}

\input{~/latex/template/preamble.tex}
\input{~/latex/template/macros.tex}

\title{\Huge{Midterm Review}}
\author{\huge{Matt Warner}}
\date{\huge{}}
\pagestyle{fancy}
\fancyhf{}
\rhead{}
\lhead{\leftmark}
\cfoot{\thepage}
% \usepackage[default]{sourcecodepro} \usepackage[T1]{fontenc}
\usepackage{pifont}

\pgfpagesdeclarelayout{boxed}
{
  \edef\pgfpageoptionborder{0pt}
}
{
  \pgfpagesphysicalpageoptions
  {%
    logical pages=1,%
  }
  \pgfpageslogicalpageoptions{1}
  {
    border code=\pgfsetlinewidth{1.5pt}\pgfstroke,%
    border shrink=\pgfpageoptionborder,%
    resized width=.95\pgfphysicalwidth,%
    resized height=.95\pgfphysicalheight,%
    center=\pgfpoint{.5\pgfphysicalwidth}{.5\pgfphysicalheight}%
  }%
}

\pgfpagesuselayout{boxed}

\begin{document}
    \maketitle
\chapter{Overview}
\section{Vocabulary}
\begin{itemize}
    \item[\ding{228}] You're responsible for knowing the terms used in the lectures.
    \item[\ding{228}] There will be some questions specifically on vocabulary.
    \item[\ding{228}] Other questions will use the terms as part of a larger question \ - \ they will not be redefined during the test.
\end{itemize}
\section{ER Diagrams}
\begin{itemize}
    \item[\ding{228}] Be able to read and interpret them.
    \item[\ding{228}] Provide cardinalities/connectivities.
    \item[\ding{228}] Degree of a relationship.
    \item[\ding{228}] Recursive relationships.
    \item[\ding{228}] Inheritance \ - \ specialization/generalization, overlapping/disjoing subtypes.
\end{itemize}
\section{Logical Data Model \ - \ Relational Model}
\begin{itemize}
    \item[\ding{228}] What makes up the relational model?
    \item[\ding{228}]  Relations, tuples, attributes, etc.
    \item[\ding{228}] Keys - primary key, candidate key, superkey.
    \item[\ding{228}] Know the requirements for each type of key.
    \item[\ding{228}] How do the above keys work with respect to functional dependencies?
    \item[\ding{228}]  Foreign Keys \ - \ what are they and how do they work?
    \item[\ding{228}]  Entity Integrity Constraint.
    \item[\ding{228}] Referential Integrity Constraint.
    \item[\ding{228}] Conversion of ER diagrams to $_3NF$ relations.
\end{itemize}	
\section{Normalization}
\begin{itemize}
    \item[\ding{228}] Be able to identify and fix violations of all 3
        \begin{itemize}[label=$\circ$]
            \item $1_NF$ \ - \ no repeating groups, all values must be atomic.
            \item $2_NF$ \ - \ No partial key dependencies.
            \item $_3NF$ \ - \ No transitive dependencies.
        \end{itemize}
\end{itemize}
\section{SQL}
\begin{itemize}
    \item[\ding{228}] Know the commands and be able to use them to make queries.
        \begin{itemize}[label=$\circ$]
            \item DDL \ - \ \texttt{CREATE TABLE, ALTER TABLE, DROP TABLE, (DESCRIBE)} 
            \item DML \ - \ \texttt{INSERT, UPDATE, DELETE, SELECT}
\end{itemize}
\item[\ding{228}] Be sure to know which commands are DDL vs . DML
\item[\ding{228}] \texttt{LIKE operator}
\item[\ding{228}] \texttt{ORDER BY}
\item[\ding{228}] \texttt{DISTINCT}
\item[\ding{228}] \texttt{GROUP BY}
\item[\ding{228}] Group functions
\item[\ding{228}] Subqueries 
    \begin{itemize}[label=$\circ$]
        \item How they get evaluated.
        \item Multi-rpw
        \item Single-value
    \end{itemize}
\end{itemize} 
\chapter{Vocabulary}
\section{Databases}
    \subsection*{Generic Database terms:}
\begin{itemize}
    \item Enterprise \ - \ A generic term for any reasonably large-scale commerical, scientific, technical, or other application.
    \item Operational data \ - \ Data maintained about the operation of an enterprise. Stuff like products, accounts, patients, students, plans. DOES NOT INCLUDE input/output data.
    \item DBMS \ - \ A collection of programs that enables users to create and maintain a database, this collection of programs forms a general-purpose software system that facilitates
        \begin{itemize}[label=$\circ$]
            \item Definition of databases.
            \item Construction of databases.
            \item manipulation of data within a database.
            \item Sharing of data between users/applications.
        \end{itemize}
\end{itemize}
\subsection*{Capabilities of a DBMS (Terms)}
    \item \textbf{Transaction management} \ - \  A feature that provides correct, concurrent access to the database, possibly by many users at the same time.
    \item \textbf{Access Control} \ - \ The ability to limit access to data by unauthorized users along with the capability to check the validity of the data.
    \item \textbf{Resiliency} \ - \ The ability to recover from system failures without losing data.

        \subsection*{Leveled Architecture of a DBMS(Terms)}
    \item \textbf{External Level} \ - \ A view or sub-schema. This is a portion of the logical database.
    \item \textbf{Logical Level} \ - \ Abstraction of the real world as it pertains to the users of the database.
    \item \textbf{Physical Level} \ - \ The collection of files and indicies stored on secondary storage device (HDD, SSD, etc.). This is the actual data.
    \subsection*{Basic Database Terminology}
\item \textbf{Instance} \ - \ An instance of the database is the actual contents of the data. An instance of the database could be an extension of the database, the current state of the database, or even a snapshot of the data at a given point in time.
\item \textbf{Schema} \ - \ The schema of a database a description of what data can be stored. This can be though of as the data members of a class. We have the names, which tell us what what the values are going to be but we dont have the values.
\item \textbf{Data Independence} \ - \ A property of an appropriately designed database system. This has to do with the Leveled Architecture, and the mapping of logical level to physical level, and logical to external.
    \begin{itemize}[label=$\circ$]
        \item \textbf{Physical data independence} \ - \ Physical schema can be changed without modifying logical schema.
        \item \textbf{Logical data independence } \ - \ Logical schema can be changed without having to modify any of the external views.
    \end{itemize}
    \item \textbf{DCL} \ - \ The Data control language.
    \item  \textbf{DDL} \ - \ Data definition language.
    \item \textbf{DMl} \ - \ Data manipulation language.
        \section{ER Diagrams}
        \subsection*{Data Models}
    \item \textbf{Data Models} \ - \ A means of describing the structure of data. An ER Diagram is a conceptual data model, but we can also have logical data models (relational, network, hierarchical, inverted list, or object-oriented). The logical data model used in this course is the relational model.
    \begin{itemize}[label=$\circ$]
        \item \textbf{Conceptual Data Model} \ - \ Shows the structure of the data including how things are related. This is a communication tool and is independent of comericial DBMSes. They are relatively easy to learn and use and help show the semantics or meaning of the data. 
        \item \textbf{Logical Data Models} \ - \ Data is stored in relations (tables). These tables have one value per cell. Commercial relational data models include DB$_2$, Oracle, Ingress, MySQL, Microsoft Access.
    \end{itemize}
    \subsection*{ERD components}
        \item \textbf{Entities} \ - \ Principle objects about which information is kept \ - \ These are ``things'' we store data about. If you were to look at the ER Diagram like a spoken language, the entities are nouns \ - \ Person, Place, thing, event.
        \item \textbf{Relationships} \ - \ Relationships connect on ore more entities together to show an association. A relationship cannot exist without at least one associated entity. Represented as diamonds.
        \item \textbf{Attributes} \ - \ Characterists of entities or of relationships. These represent some small piece of associated data. Represented by either a rounded rectangle or an oval.
            \begin{itemize}[label=$\circ$]
                \item Attributes on Entities \ - \ 
            \end{itemize}

\chapter{Relational Model}
\section{Keys}
\subsection*{Superkey}
A super key is an attribute or set of attributes whose values can uniquely identify any tuple within that relation. Every relation has at least one - the set of all attributes in the relation (since duplicate tuples are considered to be the same tuple)
\subsection*{Candidate key}
A minimal super key - the minimum set of attributes necessary to uniquely identify a tuple within the relation.
\subsection*{Primary key}
The primary key for a relation is chosen from among the relations candidate keys. It becomes the official key that is used to reference tuples within the relation. There can only be one.
\bigbreak \noindent
Once a primary key is chosen, each of the attributes in the relation will be either prime or non-prime.
\section{Requirements for keys}
\section{How do the above keys work with respect to function dependencies?}
\section{Foreign keys - what are they and how do they work?}
\section{Referential Integrity Constraint}
This applies to all foreign keys.
\bigbreak \noindent
It constrains the values of foreign keys in relations to values that acutally exist as primary keys for tuples within the home relation. 
\bigbreak \noindent
If the foreign key is otherwise allowed to be NULL, then that is also an acceptable value.
\chapter{SQL}
\section{DDL}
\subsection{creating a table}
This is the basic format of a \texttt{CREATE TABLE} statement.
\begin{minted}[linenos=false]{sql}

CREATE TABLE <table_name> (
    <attribute>  <type> [NOT NULL] [UNIQUE] [PRIMARY KEY], [...]
    [PRIMARY KEY(<pkattrs>),]
    [FOREIGN KEY(<attr_here>) REFERENCES <home_table>(<attr_home>)]
)
\end{minted}
    \begin{figure}[H]
    \centering
     % \setlength{\tabcolsep}{30}
    \begin{tabular}{l l}
    \toprule 
    Placeholder & Purpose \\
    \midrule
    \textless table\_name\textgreater & name of the table \\
    \textless attribute\textgreater & name of the attribute \\
    \textless type\textgreater & data type of the current attribute \\
    \textless pkattrs\textgreater & comma seperated list of the attributes makeing up the table's primary key. \\
    \textless attr\_here\textgreater & comma-seperated list of attributes in the current table forming a foreign key. \\
    \textless home\_table\textgreater & name of the home table \\
    \textless attr\_home \textgreater & comma-seperated list of attributes in the home table, matching the attributesin \textless attr\_here\textgreater \\
    \bottomrule
    \end{tabular}
    \end{figure}
Heres an example:
\begin{minted}[linenos=false]{sql}
CREATE TABLE Dog (
    dog_id UNSIGNED SMALLINT [AUTO_INCREMENT], 
    name VARCHAR(20),
    weight FLOAT,
    -- Primary key and foreign keys placed here (makes things more clear).
    PRIMARY KEY(dog_id)
);
\end{minted}
\subsubsection*{Setting the primary key}
There are two ways to set the primary key:
\begin{itemize}
    \item For single attribute primary keys, you can use the PRIMARY KEY column option. THe option may only be used once, and proclaims that the single attribute is the \textbf{entirety} of the primary key.
    \item If you have multiple attributes in the primary key, the only way is to add the seperate constraint:
    \begin{minted}[linenos=false]{sql}
    -- set up primary key with more than one attribute (also works with single attr).
    PRIMARY KEY(<x>, <y>, <z>, <etc>)
    \end{minted}
\end{itemize}
\subsubsection*{Setting the foreign key}
A foreign key links the current table to another table, which we call the home relation.
\begin{itemize}
    \item The foreign key must contain all of the attributes of the primary key of the home relation.
    \item They may have different names in each of the tables, but there needs to be a match for each.
    \item Each of these attributes must have the exact same data type as its counterpart in the home table.
\end{itemize}
If a table is to contain a foreign key, we include a constraint in our CREATE TABLE statement like the following
\begin{minted}[linenos=false]{sql}
FOREIGN KEY (<localnames>) REFERENCES <home_table>(<homenames>)
\end{minted}
This can be done for multiple foreign keys, filling in the placeholders \textless localnames\textgreater, \textless home\_table\textgreater, and \textless homenames\textgreater appropriately for each.
\bigbreak \noindent
Say we had: \textit{\textbf{Student}}(SSN$^\dag$, CLSYEAR, GPA, TOTALHRS)
\begin{minted}[linenos=false]{sql}
CREATE TABLE Student (
SSN CHAR(9), NOT NULL,
CLSYEAR CHAR(9),
GPA DECIMAL(4.3), 
TOTALHRS INT,

PRIMARY KEY (SSN), -- Set up the primary key seperately
FOREIGN KEY (SSN) REFERENCES Person(SSN) -- a Student is a Person
\end{minted}
\subsection{Altering a table}
An ALTER TABLE statement will allow you to have the DBMS make changes to the schema of a table that has already been created. It works with various subcommands.
\begin{itemize}
    \item ALTER TABLE ADD
    \item ALTER TABLE MODIFY
    \item ALTER TABLE DROP
\end{itemize}
\subsubsection*{ALTER TABLE ADD}
The ALTER TABLE ADD command can be used to add a new column or new columns to the schema of an existing table.
\item \textbf{Adding a single column/attribute:}
    \begin{minted}[linenos=false]{sql}
    ALTER TABLE <table_name> ADD <attribute> <type>; 
    \end{minted}
\item \textbf{Adding multiple columns/attributes}:
    \begin{minted}[linenos=false]{sql}
    ALTER TABLE <table_name> ADD (<attribute> <type>, ...); 
    \end{minted}
    Where \textless attribute\textgreater and \textless type\textgreater have the same meaning as they did with CREATE TABLE.
    For example, using the Person table that we created eariler, let's say we'd like to start storing people's birthdays. We can use the command
    \begin{minted}[linenos=false]{sql}
    ALTER TABLE ADD Birthday DATE;
    \end{minted}
    \subsubsection*{ALTER TABLE MODIFY}
    The ALTER TABLE MODIFY command can be used to change properties of a column/attribute (including type, length, and other column options) in a table that already exists.
    \begin{minted}[linenos=false]{sql}
    ALTER TABLE MODIFY <col_name> <new_options>; 
    \end{minted}
Lets say we run into some people that have last names longer than 20 characters. In order to be able to store their names without truncation, we need to change the data type for the LNAME column. We can do that with the command:
\begin{minted}[linenos=false]{sql}
ALTER TABLE Person MODIFY LNAME CHAR(32);
\end{minted}
\subsubsection*{ALTER TABLE DROP}
The ALTER TABLE DROP command can be used to remove a column/attribute from the \textit{schema} of a table.
\begin{minted}[linenos=false]{sql}
ALTER TABLE DROP <col_name>;
\end{minted}
Let's say we dont want to store information on birthdays anymore. We can use the command:
\begin{minted}[linenos=false]{sql}
ALTER TABLE Person DROP Birthday;
\end{minted}
to get rid of the Birthday column/attribute we added to the table eariler.
\subsection{DROP TABLE}
To remove a table from the database, we can use the DROP TABLE command.
\begin{minted}[linenos=false]{sql}
DROP TABLE <table>;
Note that you cant drop a table if its primary key is used as a foreign key in another table.
\end{minted}
\section{DML}
The Data Manipulation Language (DML) is the language used to work with the instance data. In SQL, this means doing things with the rows contained by tables, rather than to the tables themselves.
\bigbreak \noindent
Here is the table showing the statements that are part of the DDL in SQL, along with a short description of their function.
    \begin{figure}[ht]
    \centering
     % \setlength{\tabcolsep}{30}
    \begin{tabular}{l l}
        \toprule
        Statement & Function  \\
        \midrule
        INSERT & add a new row to a table \\
        UPDATE & change values in an existing row \\
        DELETE & remove rows from the table \\
        SELECT & display the data stored in rows (details covered later) \\
        \bottomrule
    \end{tabular}
    \end{figure}
    \subsection{INSERT}
    \begin{minted}[linenos=false]{sql}
    INSERT INTO <table_name>
        VALUES (<value_list>);

    INSERT INTO <table_name>
        (<attr_list>)
        VALUES (<value_list>)

    INSERT INTO <table_name>
        <another_query>;
    \end{minted}     
    Let's add a row into the Person table. We'll use the initial version with the four columns we created it with.
    \begin{minted}[linenos=false]{sql}
    INSERT INTO Person
        VALUES('123456789',
                'Inigo',
                'Montoya',
                '55555555');

    -- Method 2
    INSERT INTO Person
        (LNAME, FNAME, SSN)
        VALUES('Buttercup',
               'Princess',
               '987654321');
        )
    \end{minted}
    columns not in the attribute list are set to their default value if possible. This is why PHONE is NULL. This version of the INSERT statement is better if you're making SQL that needs to be in a script that is to be run later, as it tolerates more changes to the table schema than the other version. 
    \subsection*{The WHERE clause}
    When working with DML statements, it will be desirable to be able to work only with specific rows. This can be accomplished using a WHERE clause.
    \bigbreak \noindent
    The where clause is the keyword WHERE followed by an expression that evaluates to either true or false. It is included in an SQL query to control which rows are affected by the query.
    \begin{minted}[linenos=false]{sql}
    WHERE <expression> 
    \end{minted}
    The expression after WHERE is evaluated one time per row.
\item Rows where the expression evaluates as true are included in the operation.
\item Rows where the expression evaluates to false are excluded from the operation.
    \bigbreak \noindent
    WHERE clauses are generally used in UPDATE, DELETE, and SELECT statements.
    \subsection{UPDATE}
    \begin{minted}[linenos=false]{sql}
    UPDATE <table_name> 
    SET <attr> = <value> [, <attr> = <value> ...]
    [WHERE <expression>]

    -- Example
    UPDATE Student
    Set CLSYEAR = 'Senior'
    WHERE TOTALHRS > 90;
    \end{minted}
    This has the potential to change many rows, but only the rows with a value for TOTALHRS that is greater than 90.
    \bigbreak \noindent
    Lets say that you've somehow gained access to the dattabase that stores grades for the university. Coincidentally, it looks like the table you created in a 466 example! You partied way too hard last semester, so you want to change your GPA (and only your GPA) to the best one possible. If your SSN where 9999999, then the SQL statement.
    \begin{minted}[linenos=false]{sql}
    UPDATE STUDENT 
    SET GPA = 4.000
    WHERE SSN = '9999999';
    \end{minted}
    Would change your GPA to 4.000 and leave everyone else's alone.
    \bigbreak \noindent
    If you want to guarantee that you'll affect only a single row, you'll need to use an attribute that you know is unique. In general, the primary key is the best tool for this, which is why we used the SSN column in the example.
    \bigbreak \noindent
    Heres an example of using UPDATE on multiple attributes.
    \begin{minted}[linenos=false]{sql}
    -- No WHERE clauses, affects the whole table.
    UPDATE Person 
        SET FNAME = 'Spartacus',
        LNAME = ' ',
        PHONE = ' ',
    \end{minted}
    \subsection{DELETE}
    To delete the rows without getting rid of the table, use a DELETE statement.
    \begin{minted}[linenos=false]{sql}
    DELETE FROM <table_name> 
    [ WHERE <expression> ]
    \end{minted}
    Its important to realize that all rows are affected by default, so if a WHERE clause is not supplied, all of the rows will be deleted.
    \begin{minted}[linenos=false]{sql}
    DELETE FROM Person 
    WHERE SSN='123456789';
    \end{minted}
    If we want to remove a specific tuple, we need to use a unique column/columns in our WHERE clause. The primary key will always work.
    \bigbreak \noindent
    Since all rows are affected by default, failure to specify a WHERE clause will cause all of the rows of the table to be deleted
    \begin{minted}[linenos=false]{sql}
    -- Deletes every row in the Student table.
    DELETE FROM Student;
    \end{minted}
    \section{The SELECT Statement}
    \subsubsection{SELECT STatement Format}
    Two version of the basic format of a SELECT statement follow.
    \begin{minted}[linenos=false]{sql}
    SELECT [DISTINCT|ALL] <column_list>
    FROM <table_list>
    [WHERE <where_expr>]
    [GROUP BY <group_key>]
    [HAVING <having_expr]
    [ORDER BY <sortcols>] ;

    SELECT <anyexpression>
    \end{minted}
    Get supplier numbers and status for suppliers in Paris.
\begin{minted}[linenos=false]{sql}
    SELECT S, STATUS    
    FROM S
    WHERE CITY = 'Paris';
    \end{minted}
    Get part numbers for all parts suplied
    SELECT P FROM SP;
    \subsection{ORDER BY}
    We can use ORDER BY clause to enforce a sorting order on the results of our select statement.
    \begin{minted}[linenos=false]{sql}
    ORDER BY <attrs>
    \end{minted}
    \subsubsection*{Example:}
    \begin{minted}[linenos=false]{sql} SELECT S, STATUS 
    FROM S
    WHERE CITY = 'Paris'
    ORDER BY STATUS DESC -- sort based on STATUS in descending order
    \end{minted}
\end{document}
